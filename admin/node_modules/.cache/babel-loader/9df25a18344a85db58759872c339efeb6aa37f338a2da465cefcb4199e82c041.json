{"ast":null,"code":"import useCustomEffect from './useCustomEffect';\nimport { dequal } from 'dequal';\nimport useImmediateUpdateEffect from './useImmediateUpdateEffect';\nimport useEventCallback from './useEventCallback';\nimport { useState } from 'react';\nfunction isDepsEqual(_ref, _ref2) {\n  let [nextElement, nextConfig] = _ref;\n  let [prevElement, prevConfig] = _ref2;\n  return nextElement === prevElement && dequal(nextConfig, prevConfig);\n}\n\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * Depends on the `MutationObserver` api.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * useMutationObserver(element, { subtree: true }, (records) => {\n *\n * });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n * @param callback A callback fired when a mutation occurs\n */\n\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * use a `MutationObserver` and return records as the are received.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * const records = useMutationObserver(element, { subtree: true });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n */\n\nfunction useMutationObserver(element, config, callback) {\n  const [records, setRecords] = useState(null);\n  const handler = useEventCallback(callback || setRecords);\n  useCustomEffect(() => {\n    if (!element) return;\n\n    // The behavior around reusing mutation observers is confusing\n    // observing again _should_ disable the last listener but doesn't\n    // seem to always be the case, maybe just in JSDOM? In any case the cost\n    // to redeclaring it is gonna be fairly low anyway, so make it simple\n    const observer = new MutationObserver(handler);\n    observer.observe(element, config);\n    return () => {\n      observer.disconnect();\n    };\n  }, [element, config], {\n    isEqual: isDepsEqual,\n    // Intentionally done in render, otherwise observer will miss any\n    // changes made to the DOM during this update\n    effectHook: useImmediateUpdateEffect\n  });\n  return callback ? void 0 : records || [];\n}\nexport default useMutationObserver;","map":{"version":3,"names":["useCustomEffect","dequal","useImmediateUpdateEffect","useEventCallback","useState","isDepsEqual","_ref","_ref2","nextElement","nextConfig","prevElement","prevConfig","useMutationObserver","element","config","callback","records","setRecords","handler","observer","MutationObserver","observe","disconnect","isEqual","effectHook"],"sources":["C:/Users/josef/OneDrive/Ãrea de Trabalho/IFSC/PI/e-commerce/node_modules/@restart/hooks/esm/useMutationObserver.js"],"sourcesContent":["import useCustomEffect from './useCustomEffect';\nimport { dequal } from 'dequal';\nimport useImmediateUpdateEffect from './useImmediateUpdateEffect';\nimport useEventCallback from './useEventCallback';\nimport { useState } from 'react';\nfunction isDepsEqual([nextElement, nextConfig], [prevElement, prevConfig]) {\n  return nextElement === prevElement && dequal(nextConfig, prevConfig);\n}\n\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * Depends on the `MutationObserver` api.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * useMutationObserver(element, { subtree: true }, (records) => {\n *\n * });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n * @param callback A callback fired when a mutation occurs\n */\n\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * use a `MutationObserver` and return records as the are received.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * const records = useMutationObserver(element, { subtree: true });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n */\n\nfunction useMutationObserver(element, config, callback) {\n  const [records, setRecords] = useState(null);\n  const handler = useEventCallback(callback || setRecords);\n  useCustomEffect(() => {\n    if (!element) return;\n\n    // The behavior around reusing mutation observers is confusing\n    // observing again _should_ disable the last listener but doesn't\n    // seem to always be the case, maybe just in JSDOM? In any case the cost\n    // to redeclaring it is gonna be fairly low anyway, so make it simple\n    const observer = new MutationObserver(handler);\n    observer.observe(element, config);\n    return () => {\n      observer.disconnect();\n    };\n  }, [element, config], {\n    isEqual: isDepsEqual,\n    // Intentionally done in render, otherwise observer will miss any\n    // changes made to the DOM during this update\n    effectHook: useImmediateUpdateEffect\n  });\n  return callback ? void 0 : records || [];\n}\nexport default useMutationObserver;"],"mappings":"AAAA,OAAOA,eAAe,MAAM,mBAAmB;AAC/C,SAASC,MAAM,QAAQ,QAAQ;AAC/B,OAAOC,wBAAwB,MAAM,4BAA4B;AACjE,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,SAASC,QAAQ,QAAQ,OAAO;AAChC,SAASC,WAAWA,CAAAC,IAAA,EAAAC,KAAA,EAAuD;EAAA,IAAtD,CAACC,WAAW,EAAEC,UAAU,CAAC,GAAAH,IAAA;EAAA,IAAE,CAACI,WAAW,EAAEC,UAAU,CAAC,GAAAJ,KAAA;EACvE,OAAOC,WAAW,KAAKE,WAAW,IAAIT,MAAM,CAACQ,UAAU,EAAEE,UAAU,CAAC;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,mBAAmBA,CAACC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACtD,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAGb,QAAQ,CAAC,IAAI,CAAC;EAC5C,MAAMc,OAAO,GAAGf,gBAAgB,CAACY,QAAQ,IAAIE,UAAU,CAAC;EACxDjB,eAAe,CAAC,MAAM;IACpB,IAAI,CAACa,OAAO,EAAE;;IAEd;IACA;IACA;IACA;IACA,MAAMM,QAAQ,GAAG,IAAIC,gBAAgB,CAACF,OAAO,CAAC;IAC9CC,QAAQ,CAACE,OAAO,CAACR,OAAO,EAAEC,MAAM,CAAC;IACjC,OAAO,MAAM;MACXK,QAAQ,CAACG,UAAU,EAAE;IACvB,CAAC;EACH,CAAC,EAAE,CAACT,OAAO,EAAEC,MAAM,CAAC,EAAE;IACpBS,OAAO,EAAElB,WAAW;IACpB;IACA;IACAmB,UAAU,EAAEtB;EACd,CAAC,CAAC;EACF,OAAOa,QAAQ,GAAG,KAAK,CAAC,GAAGC,OAAO,IAAI,EAAE;AAC1C;AACA,eAAeJ,mBAAmB"},"metadata":{},"sourceType":"module","externalDependencies":[]}