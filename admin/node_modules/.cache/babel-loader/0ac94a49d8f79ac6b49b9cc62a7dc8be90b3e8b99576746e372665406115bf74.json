{"ast":null,"code":"/* eslint-disable react-hooks/exhaustive-deps */\nimport querySelectorAll from 'dom-helpers/querySelectorAll';\nimport React, { useCallback, useContext, useLayoutEffect, useMemo, useState, useRef } from 'react';\nexport const FocusListContext = /*#__PURE__*/React.createContext(null);\nconst defaultOpts = {\n  behavior: 'stop'\n};\nexport function useListOption(dataItem) {\n  const ctx = useContext(FocusListContext);\n  const prevElement = useRef(null); // this is a bit convoluted because we want to use a ref object, a callback ref\n  // causes an extra render which is fine except that it means the list hook for\n  // anchor items fires before elements are processed\n\n  const ref = useRef(null);\n  useLayoutEffect(() => () => {\n    ctx == null ? void 0 : ctx.map.delete(ref.current);\n  }, []);\n  useLayoutEffect(() => {\n    if (prevElement.current !== ref.current) {\n      ctx == null ? void 0 : ctx.map.delete(prevElement.current);\n    }\n    prevElement.current = ref.current;\n    if (ref.current && (ctx == null ? void 0 : ctx.map.get(ref.current)) !== dataItem) {\n      ctx == null ? void 0 : ctx.map.set(ref.current, dataItem);\n    }\n  });\n  const focused = dataItem === (ctx == null ? void 0 : ctx.focusedItem);\n  return [ref, focused, focused ? ctx == null ? void 0 : ctx.activeId : undefined];\n}\nexport const useFocusList = _ref => {\n  let {\n    scope: listRef,\n    anchorItem,\n    focusFirstItem: _focusFirstItem = false,\n    scopeSelector: _scopeSelector = '',\n    activeId\n  } = _ref;\n  const map = useMemo(() => new WeakMap(), []);\n  const [focusedItem, setFocusedItem] = useState();\n  const itemSelector = `${_scopeSelector} [data-rw-focusable]`.trim();\n  const get = () => {\n    const items = querySelectorAll(listRef.current, itemSelector);\n    return [items, items.find(e => e.dataset.rwFocused === '')];\n  };\n  const list = useMemo(() => {\n    return {\n      size() {\n        const [items] = get();\n        return items.length;\n      },\n      get,\n      toDataItem: el => map.get(el),\n      first() {\n        const [[first]] = get();\n        return first;\n      },\n      focus(el) {\n        if (!el || map.has(el)) setFocusedItem(el ? map.get(el) : undefined);\n      },\n      last() {\n        const [items] = get();\n        return items[items.length - 1];\n      },\n      next() {\n        let {\n          behavior\n        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOpts;\n        const [items, focusedItem] = get();\n        let nextIdx = items.indexOf(focusedItem) + 1;\n        if (nextIdx >= items.length) {\n          if (behavior === 'loop') return items[0];\n          if (behavior === 'clear') return undefined;\n          return focusedItem;\n        }\n        return items[nextIdx];\n      },\n      prev() {\n        let {\n          behavior\n        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOpts;\n        const [items, focusedItem] = get();\n        let nextIdx = Math.max(0, items.indexOf(focusedItem)) - 1;\n        if (nextIdx < 0) {\n          if (behavior === 'loop') return items[items.length - 1];\n          if (behavior === 'clear') return undefined;\n          return focusedItem;\n        }\n        return items[nextIdx];\n      }\n    };\n  }, []);\n  useLayoutEffect(() => {\n    if (!anchorItem) {\n      list.focus(null);\n      return;\n    }\n    const element = get()[0].find(el => list.toDataItem(el) === anchorItem);\n    list.focus(element);\n  }, [anchorItem]);\n  useLayoutEffect(() => {\n    if (!listRef.current) return;\n    const [, focusedElement] = get();\n    const hasItem = focusedElement != null;\n    if (!hasItem && _focusFirstItem || hasItem && !listRef.current.contains(focusedElement)) {\n      if (_focusFirstItem) list.focus(list.first());else list.focus(null);\n    }\n  });\n  const context = useMemo(() => ({\n    map,\n    focusedItem,\n    activeId\n  }), [focusedItem, activeId]);\n  list.context = context;\n  list.getFocused = useCallback(() => focusedItem, [focusedItem]);\n  list.hasFocused = () => focusedItem !== undefined;\n  return list;\n};","map":{"version":3,"names":["querySelectorAll","React","useCallback","useContext","useLayoutEffect","useMemo","useState","useRef","FocusListContext","createContext","defaultOpts","behavior","useListOption","dataItem","ctx","prevElement","ref","map","delete","current","get","set","focused","focusedItem","activeId","undefined","useFocusList","_ref","scope","listRef","anchorItem","focusFirstItem","_focusFirstItem","scopeSelector","_scopeSelector","WeakMap","setFocusedItem","itemSelector","trim","items","find","e","dataset","rwFocused","list","size","length","toDataItem","el","first","focus","has","last","next","arguments","nextIdx","indexOf","prev","Math","max","element","focusedElement","hasItem","contains","context","getFocused","hasFocused"],"sources":["C:/Users/josef/OneDrive/Ãrea de Trabalho/IFSC/PI/e-commerce/node_modules/react-widgets/esm/FocusListContext.js"],"sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\nimport querySelectorAll from 'dom-helpers/querySelectorAll';\nimport React, { useCallback, useContext, useLayoutEffect, useMemo, useState, useRef } from 'react';\nexport const FocusListContext = /*#__PURE__*/React.createContext(null);\nconst defaultOpts = {\n  behavior: 'stop'\n};\nexport function useListOption(dataItem) {\n  const ctx = useContext(FocusListContext);\n  const prevElement = useRef(null); // this is a bit convoluted because we want to use a ref object, a callback ref\n  // causes an extra render which is fine except that it means the list hook for\n  // anchor items fires before elements are processed\n\n  const ref = useRef(null);\n  useLayoutEffect(() => () => {\n    ctx == null ? void 0 : ctx.map.delete(ref.current);\n  }, []);\n  useLayoutEffect(() => {\n    if (prevElement.current !== ref.current) {\n      ctx == null ? void 0 : ctx.map.delete(prevElement.current);\n    }\n\n    prevElement.current = ref.current;\n\n    if (ref.current && (ctx == null ? void 0 : ctx.map.get(ref.current)) !== dataItem) {\n      ctx == null ? void 0 : ctx.map.set(ref.current, dataItem);\n    }\n  });\n  const focused = dataItem === (ctx == null ? void 0 : ctx.focusedItem);\n  return [ref, focused, focused ? ctx == null ? void 0 : ctx.activeId : undefined];\n}\nexport const useFocusList = ({\n  scope: listRef,\n  anchorItem,\n  focusFirstItem: _focusFirstItem = false,\n  scopeSelector: _scopeSelector = '',\n  activeId\n}) => {\n  const map = useMemo(() => new WeakMap(), []);\n  const [focusedItem, setFocusedItem] = useState();\n  const itemSelector = `${_scopeSelector} [data-rw-focusable]`.trim();\n\n  const get = () => {\n    const items = querySelectorAll(listRef.current, itemSelector);\n    return [items, items.find(e => e.dataset.rwFocused === '')];\n  };\n\n  const list = useMemo(() => {\n    return {\n      size() {\n        const [items] = get();\n        return items.length;\n      },\n\n      get,\n      toDataItem: el => map.get(el),\n\n      first() {\n        const [[first]] = get();\n        return first;\n      },\n\n      focus(el) {\n        if (!el || map.has(el)) setFocusedItem(el ? map.get(el) : undefined);\n      },\n\n      last() {\n        const [items] = get();\n        return items[items.length - 1];\n      },\n\n      next({\n        behavior\n      } = defaultOpts) {\n        const [items, focusedItem] = get();\n        let nextIdx = items.indexOf(focusedItem) + 1;\n\n        if (nextIdx >= items.length) {\n          if (behavior === 'loop') return items[0];\n          if (behavior === 'clear') return undefined;\n          return focusedItem;\n        }\n\n        return items[nextIdx];\n      },\n\n      prev({\n        behavior\n      } = defaultOpts) {\n        const [items, focusedItem] = get();\n        let nextIdx = Math.max(0, items.indexOf(focusedItem)) - 1;\n\n        if (nextIdx < 0) {\n          if (behavior === 'loop') return items[items.length - 1];\n          if (behavior === 'clear') return undefined;\n          return focusedItem;\n        }\n\n        return items[nextIdx];\n      }\n\n    };\n  }, []);\n  useLayoutEffect(() => {\n    if (!anchorItem) {\n      list.focus(null);\n      return;\n    }\n\n    const element = get()[0].find(el => list.toDataItem(el) === anchorItem);\n    list.focus(element);\n  }, [anchorItem]);\n  useLayoutEffect(() => {\n    if (!listRef.current) return;\n    const [, focusedElement] = get();\n    const hasItem = focusedElement != null;\n\n    if (!hasItem && _focusFirstItem || hasItem && !listRef.current.contains(focusedElement)) {\n      if (_focusFirstItem) list.focus(list.first());else list.focus(null);\n    }\n  });\n  const context = useMemo(() => ({\n    map,\n    focusedItem,\n    activeId\n  }), [focusedItem, activeId]);\n  list.context = context;\n  list.getFocused = useCallback(() => focusedItem, [focusedItem]);\n\n  list.hasFocused = () => focusedItem !== undefined;\n\n  return list;\n};"],"mappings":"AAAA;AACA,OAAOA,gBAAgB,MAAM,8BAA8B;AAC3D,OAAOC,KAAK,IAAIC,WAAW,EAAEC,UAAU,EAAEC,eAAe,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,MAAM,QAAQ,OAAO;AAClG,OAAO,MAAMC,gBAAgB,GAAG,aAAaP,KAAK,CAACQ,aAAa,CAAC,IAAI,CAAC;AACtE,MAAMC,WAAW,GAAG;EAClBC,QAAQ,EAAE;AACZ,CAAC;AACD,OAAO,SAASC,aAAaA,CAACC,QAAQ,EAAE;EACtC,MAAMC,GAAG,GAAGX,UAAU,CAACK,gBAAgB,CAAC;EACxC,MAAMO,WAAW,GAAGR,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;EAClC;EACA;;EAEA,MAAMS,GAAG,GAAGT,MAAM,CAAC,IAAI,CAAC;EACxBH,eAAe,CAAC,MAAM,MAAM;IAC1BU,GAAG,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACG,GAAG,CAACC,MAAM,CAACF,GAAG,CAACG,OAAO,CAAC;EACpD,CAAC,EAAE,EAAE,CAAC;EACNf,eAAe,CAAC,MAAM;IACpB,IAAIW,WAAW,CAACI,OAAO,KAAKH,GAAG,CAACG,OAAO,EAAE;MACvCL,GAAG,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACG,GAAG,CAACC,MAAM,CAACH,WAAW,CAACI,OAAO,CAAC;IAC5D;IAEAJ,WAAW,CAACI,OAAO,GAAGH,GAAG,CAACG,OAAO;IAEjC,IAAIH,GAAG,CAACG,OAAO,IAAI,CAACL,GAAG,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACG,GAAG,CAACG,GAAG,CAACJ,GAAG,CAACG,OAAO,CAAC,MAAMN,QAAQ,EAAE;MACjFC,GAAG,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACG,GAAG,CAACI,GAAG,CAACL,GAAG,CAACG,OAAO,EAAEN,QAAQ,CAAC;IAC3D;EACF,CAAC,CAAC;EACF,MAAMS,OAAO,GAAGT,QAAQ,MAAMC,GAAG,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACS,WAAW,CAAC;EACrE,OAAO,CAACP,GAAG,EAAEM,OAAO,EAAEA,OAAO,GAAGR,GAAG,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACU,QAAQ,GAAGC,SAAS,CAAC;AAClF;AACA,OAAO,MAAMC,YAAY,GAAGC,IAAA,IAMtB;EAAA,IANuB;IAC3BC,KAAK,EAAEC,OAAO;IACdC,UAAU;IACVC,cAAc,EAAEC,eAAe,GAAG,KAAK;IACvCC,aAAa,EAAEC,cAAc,GAAG,EAAE;IAClCV;EACF,CAAC,GAAAG,IAAA;EACC,MAAMV,GAAG,GAAGZ,OAAO,CAAC,MAAM,IAAI8B,OAAO,EAAE,EAAE,EAAE,CAAC;EAC5C,MAAM,CAACZ,WAAW,EAAEa,cAAc,CAAC,GAAG9B,QAAQ,EAAE;EAChD,MAAM+B,YAAY,GAAI,GAAEH,cAAe,sBAAqB,CAACI,IAAI,EAAE;EAEnE,MAAMlB,GAAG,GAAGA,CAAA,KAAM;IAChB,MAAMmB,KAAK,GAAGvC,gBAAgB,CAAC6B,OAAO,CAACV,OAAO,EAAEkB,YAAY,CAAC;IAC7D,OAAO,CAACE,KAAK,EAAEA,KAAK,CAACC,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,OAAO,CAACC,SAAS,KAAK,EAAE,CAAC,CAAC;EAC7D,CAAC;EAED,MAAMC,IAAI,GAAGvC,OAAO,CAAC,MAAM;IACzB,OAAO;MACLwC,IAAIA,CAAA,EAAG;QACL,MAAM,CAACN,KAAK,CAAC,GAAGnB,GAAG,EAAE;QACrB,OAAOmB,KAAK,CAACO,MAAM;MACrB,CAAC;MAED1B,GAAG;MACH2B,UAAU,EAAEC,EAAE,IAAI/B,GAAG,CAACG,GAAG,CAAC4B,EAAE,CAAC;MAE7BC,KAAKA,CAAA,EAAG;QACN,MAAM,CAAC,CAACA,KAAK,CAAC,CAAC,GAAG7B,GAAG,EAAE;QACvB,OAAO6B,KAAK;MACd,CAAC;MAEDC,KAAKA,CAACF,EAAE,EAAE;QACR,IAAI,CAACA,EAAE,IAAI/B,GAAG,CAACkC,GAAG,CAACH,EAAE,CAAC,EAAEZ,cAAc,CAACY,EAAE,GAAG/B,GAAG,CAACG,GAAG,CAAC4B,EAAE,CAAC,GAAGvB,SAAS,CAAC;MACtE,CAAC;MAED2B,IAAIA,CAAA,EAAG;QACL,MAAM,CAACb,KAAK,CAAC,GAAGnB,GAAG,EAAE;QACrB,OAAOmB,KAAK,CAACA,KAAK,CAACO,MAAM,GAAG,CAAC,CAAC;MAChC,CAAC;MAEDO,IAAIA,CAAA,EAEa;QAAA,IAFZ;UACH1C;QACF,CAAC,GAAA2C,SAAA,CAAAR,MAAA,QAAAQ,SAAA,QAAA7B,SAAA,GAAA6B,SAAA,MAAG5C,WAAW;QACb,MAAM,CAAC6B,KAAK,EAAEhB,WAAW,CAAC,GAAGH,GAAG,EAAE;QAClC,IAAImC,OAAO,GAAGhB,KAAK,CAACiB,OAAO,CAACjC,WAAW,CAAC,GAAG,CAAC;QAE5C,IAAIgC,OAAO,IAAIhB,KAAK,CAACO,MAAM,EAAE;UAC3B,IAAInC,QAAQ,KAAK,MAAM,EAAE,OAAO4B,KAAK,CAAC,CAAC,CAAC;UACxC,IAAI5B,QAAQ,KAAK,OAAO,EAAE,OAAOc,SAAS;UAC1C,OAAOF,WAAW;QACpB;QAEA,OAAOgB,KAAK,CAACgB,OAAO,CAAC;MACvB,CAAC;MAEDE,IAAIA,CAAA,EAEa;QAAA,IAFZ;UACH9C;QACF,CAAC,GAAA2C,SAAA,CAAAR,MAAA,QAAAQ,SAAA,QAAA7B,SAAA,GAAA6B,SAAA,MAAG5C,WAAW;QACb,MAAM,CAAC6B,KAAK,EAAEhB,WAAW,CAAC,GAAGH,GAAG,EAAE;QAClC,IAAImC,OAAO,GAAGG,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEpB,KAAK,CAACiB,OAAO,CAACjC,WAAW,CAAC,CAAC,GAAG,CAAC;QAEzD,IAAIgC,OAAO,GAAG,CAAC,EAAE;UACf,IAAI5C,QAAQ,KAAK,MAAM,EAAE,OAAO4B,KAAK,CAACA,KAAK,CAACO,MAAM,GAAG,CAAC,CAAC;UACvD,IAAInC,QAAQ,KAAK,OAAO,EAAE,OAAOc,SAAS;UAC1C,OAAOF,WAAW;QACpB;QAEA,OAAOgB,KAAK,CAACgB,OAAO,CAAC;MACvB;IAEF,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EACNnD,eAAe,CAAC,MAAM;IACpB,IAAI,CAAC0B,UAAU,EAAE;MACfc,IAAI,CAACM,KAAK,CAAC,IAAI,CAAC;MAChB;IACF;IAEA,MAAMU,OAAO,GAAGxC,GAAG,EAAE,CAAC,CAAC,CAAC,CAACoB,IAAI,CAACQ,EAAE,IAAIJ,IAAI,CAACG,UAAU,CAACC,EAAE,CAAC,KAAKlB,UAAU,CAAC;IACvEc,IAAI,CAACM,KAAK,CAACU,OAAO,CAAC;EACrB,CAAC,EAAE,CAAC9B,UAAU,CAAC,CAAC;EAChB1B,eAAe,CAAC,MAAM;IACpB,IAAI,CAACyB,OAAO,CAACV,OAAO,EAAE;IACtB,MAAM,GAAG0C,cAAc,CAAC,GAAGzC,GAAG,EAAE;IAChC,MAAM0C,OAAO,GAAGD,cAAc,IAAI,IAAI;IAEtC,IAAI,CAACC,OAAO,IAAI9B,eAAe,IAAI8B,OAAO,IAAI,CAACjC,OAAO,CAACV,OAAO,CAAC4C,QAAQ,CAACF,cAAc,CAAC,EAAE;MACvF,IAAI7B,eAAe,EAAEY,IAAI,CAACM,KAAK,CAACN,IAAI,CAACK,KAAK,EAAE,CAAC,CAAC,KAAKL,IAAI,CAACM,KAAK,CAAC,IAAI,CAAC;IACrE;EACF,CAAC,CAAC;EACF,MAAMc,OAAO,GAAG3D,OAAO,CAAC,OAAO;IAC7BY,GAAG;IACHM,WAAW;IACXC;EACF,CAAC,CAAC,EAAE,CAACD,WAAW,EAAEC,QAAQ,CAAC,CAAC;EAC5BoB,IAAI,CAACoB,OAAO,GAAGA,OAAO;EACtBpB,IAAI,CAACqB,UAAU,GAAG/D,WAAW,CAAC,MAAMqB,WAAW,EAAE,CAACA,WAAW,CAAC,CAAC;EAE/DqB,IAAI,CAACsB,UAAU,GAAG,MAAM3C,WAAW,KAAKE,SAAS;EAEjD,OAAOmB,IAAI;AACb,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}